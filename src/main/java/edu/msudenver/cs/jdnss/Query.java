// Generated by delombok at Fri Mar 20 22:19:47 CET 2020
package edu.msudenver.cs.jdnss;

import org.apache.logging.log4j.Logger;
import java.util.Arrays;
import java.util.Map;

class Queries {
    private final String name;
    private final RRCode type;
    private final int qclass;
    private final boolean QU;

    Queries(final String name, final RRCode type, final int qclass, final boolean QU) {
        this.name = name;
        this.type = type;
        this.qclass = qclass;
        this.QU = QU;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public java.lang.String toString() {
        return "Queries(name=" + this.getName() + ", type=" + this.getType() + ", qclass=" + this.getQclass() + ", QU=" + this.isQU() + ")";
    }

    @java.lang.SuppressWarnings("all")
    public String getName() {
        return this.name;
    }

    @java.lang.SuppressWarnings("all")
    public RRCode getType() {
        return this.type;
    }

    @java.lang.SuppressWarnings("all")
    public int getQclass() {
        return this.qclass;
    }

    @java.lang.SuppressWarnings("all")
    public boolean isQU() {
        return this.QU;
    }
}

class Query {
    private final Logger logger = JDNSS.logger;
    private final Header header;
    private final byte[] buffer;
    private Queries[] queries;
    private OPTRR optrr;

    /**
     * creates a Query from a packet
     */
    Query(byte[] buffer) {
        this.buffer = buffer;
        this.header = new Header(buffer);
    }

    /**
     * Evaluates and saves all questions
     */
    void parseQueries(String clientIPaddress) {
        logger.traceEntry();
        /*
        The question section is used to carry the "question" in most queries,
        i.e., the parameters that deinfo what is being asked.  The section
        contains QDCOUNT(usually 1) entries, each of the following format:

        1  1  1  1  1  1
        0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |                                               |
        /                     QNAME                     /
        /                                               /
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |                     QTYPE                     |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        |                     QCLASS                    |
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
        */
        int location = 12;
        queries = new Queries[header.getNumQuestions()];
        for (int i = 0; i < header.getNumQuestions(); i++) {
            Map.Entry<String, Integer> StringAndNumber = Utils.parseName(location, buffer);
            location = StringAndNumber.getValue();
            int qtype = Utils.addThem(buffer[location++], buffer[location++]);
            int qclass = Utils.addThem(buffer[location++], buffer[location++]);
            boolean QU = (qclass & 49152) == 49152;
            queries[i] = new Queries(StringAndNumber.getKey(), RRCode.findCode(qtype), qclass, QU);
            /*
            ** Multicast DNS defines the top bit in the class field of a
            ** DNS question as the unicast-response bit.  When this bit is
            ** set in a question, it indicates that the querier is willing
            ** to accept unicast replies in response to this specific
            ** query, as well as the usual multicast responses.  These
            ** questions requesting unicast responses are referred to as
            ** "QU" questions, to distinguish them from the more usual
            ** questions requesting multicast responses ("QM" questions).
            */
        }
        /* For servers with DNS Cookies enabled, the QUERY opcode behavior is
        extended to support queries with an empty Question Section (a QDCOUNT
            of zero (0)), provided that an OPT record is present with a COOKIE
        option.  Such servers will send a reply that has an empty
        Answer Section and has a COOKIE option containing the Client Cookie
        and a valid Server Cookie. */
        /*
        At a server where DNS Cookies are not implemented and enabled, the
        presence of a COOKIE option is ignored and the server responds as if
        no COOKIE option had been included in the request.
        */
        for (int i = 0; i < header.getNumAdditionals(); i++) {
            logger.traceEntry();
            // When an OPT RR is included within any DNS message, it
            // MUST be the only OPT RR in that message.
            assert header.getNumAdditionals() == 1;
            this.optrr = new OPTRR(Arrays.copyOfRange(buffer, location, buffer.length));
            //process and transform? optrr for a resonse
            // need to set the RCODE in header for the response needs to be FORMERR
            if (optrr.hasFormErr()) {
                header.setRcode(ErrorCodes.FORMERROR.getCode());
            }
            if (optrr.isCookie()) {
                optrr.createServerCookie(clientIPaddress, header);
            }
        }
    }

    byte[] buildResponseQueries() {
        byte[] questions = new byte[0];
        for (Queries query : this.getQueries()) {
            questions = Utils.combine(questions, Utils.convertString(query.getName()));
            questions = Utils.combine(questions, Utils.getTwoBytes(query.getType().getCode(), 2));
            questions = Utils.combine(questions, Utils.getTwoBytes(query.getQclass(), 2));
        }
        return questions;
    }

    @java.lang.Override
    @java.lang.SuppressWarnings("all")
    public java.lang.String toString() {
        return "Query(logger=" + this.logger + ", header=" + this.getHeader() + ", buffer=" + java.util.Arrays.toString(this.getBuffer()) + ", queries=" + java.util.Arrays.deepToString(this.getQueries()) + ", optrr=" + this.getOptrr() + ")";
    }

    @java.lang.SuppressWarnings("all")
    public Header getHeader() {
        return this.header;
    }

    @java.lang.SuppressWarnings("all")
    public byte[] getBuffer() {
        return this.buffer;
    }

    @java.lang.SuppressWarnings("all")
    public Queries[] getQueries() {
        return this.queries;
    }

    @java.lang.SuppressWarnings("all")
    public OPTRR getOptrr() {
        return this.optrr;
    }
}